!TITLE(hVision tutorial)

# [hVision][project] tutorial


## installation

[installation instructions](https://github.com/Hiroki-Yoshida7/Image-Processing-Vision/tree/reorg)


## working environment

We need just an editor and a command line terminal, but
I recommend that you configure your editor to compile and run programs directly using shortcut keys. Most people prefer **emacs** or **vim** but I happily use **gedit** with "snippets" and "external tools" configured to do many useful tasks.

It is also convenient to open a navigation tab with the local Haddock documentation.

## hello world!

Show a single image:

HSFILE(../tour/hello.hs)



Show a live video sequence captured from the input source (the webcam by default):

HSFILE(../tour/play.hs)

##Channels

The pipeline generated by the input sequence is a "Channels" structure. We choose any projection function for the observation windows.

HSFILE(../tour/playgray.hs)


The pipeline functions are composed with (>>>). "arr" maps a pure function on the infinite list of data items generated by the camera.

HSFILE(../tour/play1.hs)

The above processing pipeline p produces grayscale images. The observation windows show some features of the processed objects, but the results are not sent forward.


## sMonitor

We can show different things in a window, selected with the mouse wheel:

HSFILE(../tour/smon.hs)

The Show instance of the Channels structure shows the separate RGB channels and the grayscale image in a 4x4 grid.

HSFILE(../tour/chanShow.hs)


We can apply an IO operation to each element in the input pipeline:

HSFILE(../tour/arrIO.hs)

## recommended program structure

The development of certain algorithms requires displaying many
intermediate results for debugging purposes. As a result of fast prototyping,
some pieces of code are often included in the display functions, which at the end requires some
refactoring.

A way to keep things well organized is to separate the algorithmic work from the
display functions. I find it useful to define a record with all the intermediate
steps in a computation and populate it in a worker function possibly depending on
interactive parameters. If the experiment is successful it is easy to extract the
relevant code to a library function.

HSFILE(../tour/work.hs)

## arrow interface

**arrows**: Arrow notation (include diagram):



**loop**: circuit loop in arrow notation:

HSFILE(../tour/loop.hs)

**choice**: circuit with choice.

HSFILE(../tour/choice.hs)

**circuit**, **nocircuit**: arrow notation and recursive do.

**fast-slow**: pipeline at two frame rates. Check that there is no leaks.

## run modes

**play0**: create a pipeline step explicitly using transUI

**play3**: insert frames in the video sequence.

HSFILE(../tour/play3.hs)

**play4**: add frame rate measurement window:

HSFILE(../tour/play4.hs)

**testwebcam**: explicitly open the webcam image source.

HSFILE(../tour/testwebcam.hs)


## general pipelines

**play5**: the pipeline can be used with sequences of any kind of information. This is a clock:

HSFILE(../tour/play5.hs)

**play6**: In this example we generate random numbers at about 1000Hz, and take the average of each group of 100 elements, producing a final 10Hz output.

HSFILE(../tour/play6.hs)


**runmode0**: work without GUI

HSFILE(../tour/runmode0.hs)

**runmode1**: normal threaded mode

HSFILE(../tour/runmode1.hs)

**runmode00**: explicitly open the input source and extract elements:

HSFILE(../tour/runmode00.hs)

A Maybe type is used to indicate if there is a new element available in the stream or
if there are no remaining items. We usually work with the data type ‘Channels’ which provides a
few useful image color channels and image formats.



**runmode01**: run a pipeline wihout a GUI:

HSFILE(../tour/runmode01.hs)


**nogui**: run a pipeline without GUI:

HSFILE(../tour/nogui.hs)




**runmode2**: threaded GUI, returning result:

HSFILE(../tour/runmode01.hs)

**runmode02**: nonthreaded GUI, returning result:

HSFILE(../tour/runmode02.hs)

**runmode3**: nonthreaded GUI, returning result:

HSFILE(../tour/runmode3.hs)

**runmode03**: threaded GUI, returning result:

HSFILE(../tour/runmode03.hs)

**runmode4**: nonthreaded GUI, returning result:

HSFILE(../tour/runmode4.hs)

**runmode04**: load single image from the command line:

HSFILE(../tour/runmode04.hs)

**runmode05**: load lazily all images in a directory:

HSFILE(../tour/runmode05.hs)

**runmode06**: process pipeline and then work with it:

HSFILE(../tour/runmode06.hs)


**runS**: same thing.

HSFILE(../tour/runS.hs)

**scanl1**: scanl to perform a recursive computation. The video is shown inside the video. Run as

<pre id="samp">
$ ./scanl1 ../../data/videos/rcube.avi
</pre>

HSFILE(../tour/scanl1.hs)


**single**: read a list of image files and lazily work with them. Run as

<pre id="samp">
    (fixme)
</pre>

HSFILE(../tour/single.hs)


**skip**: drop the first n frames of the input sequence

<pre id="samp">
    (fixme)
</pre>

HSFILE(../tour/skip.hs)


## interface windows

Used in pipelines.

example of an intercative window which captures clicked points:

HSFILE(../tour/interface.hs)


**passROI**: example of an interactive window to capture the region of interest.

HSFILE(../tour/passROI.hs)


## standalone windows

GUI for more conventional programs.

"standalone" interactive graphic window. Click to change state:

HSFILE(../tour/stand1.hs)

"browser" window. Use the wheel to see the elements of a list of things:

HSFILE(../tour/stand2.hs)

"editor" window. change the elements of a list of things:

HSFILE(../tour/stand3.hs)

## Drawing

**draw**, **drawParam**, **drawParam3D**: example of drawing functions.


**interactive3D**: add elements to a 3D graphic from ghci.

## interactive parameter windows

"autoParam" automagically creates the parameter record, the interactive window,
and support for command line arguments. "withParam" supplies the "current" value to a pure function.

HSFILE(../tour/param2.hs)

HSFILE(../tour/param3.hs)

The initial value of any parameter can be set in the command line:

<pre id="samp">
    $ ./ param --g-sigma=1.5
</pre>

all parameter windows can be removed:

<pre id="samp">
    $ ./ param --default
</pre>

observe and sMonitor windows can be selectively removed:

<pre id="samp">
    $ ./ param --no-gauss
</pre>

--options shows all options recognized by a program


## connect windows

Changes in the state of a window may trigger changes in other windows:

HSFILE(../tour/connect.hs)

Using the general purpuse "clickPoints" window:

HSFILE(../tour/clickPoints.hs)

Explicit use of "evNotify" to do things when the state of an interface window changes.

HSFILE(../examples/cameracontrol.hs)


## other / WIP

**noleak**, **noleak2**: check that there are no space leaks caused by observed results no longer used.

**noguiraw**: tests of low level lazyIO functions.

**batch**, **batch2** (run modes?)


- - -

[back to help][help]

!INCLUDE(LINKS)

